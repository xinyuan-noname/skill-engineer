{{#d "zhu"}}
zhuSkill: true,
{{/d}}
trigger: { 
	player: ["chooseToRespondBefore", "chooseToUseBefore"] 
},
{{#filter}}
	if (event.responded) return false;
	if (player.storage.hujiaing) return false;
	{{#d "zhu"}}
	if (!player.hasZhuSkill("hujia")) return false;
	{{/d}}
	if (!event.filterCard({ name: "shan", isCard: true }, player, event)) return false;
	return game.hasPlayer(current => current != player && current.group == {{#r "group"}}"{{@root.group}}"{{else}}"wei"{{/r}});
{{/filter}}
{{#content async=true}}
	while (true) {
		let bool;
		if (!event.current) event.current = player.next;
		if (event.current == player) return;
		else if (event.current.group == {{#r "group"}}"{{@root.group}}"{{else}}"wei"{{/r}}) {
			if ((event.current == game.me && !_status.auto) || get.attitude(event.current, player) > 2 || event.current.isOnline())
			{
				player.storage.hujiaing = true;
				const next = event.current.chooseToRespond("是否替" + get.translation(player) + "打出一张闪？", { name: "shan" });
				next.set("ai", () => {
					const event = _status.event;
					return get.attitude(event.player, event.source) - 2;
				});
				next.set("skillwarn", "替" + get.translation(player) + "打出一张闪");
				next.autochoose = lib.filter.autoRespondShan;
				next.set("source", player);
				bool = await next.forResultBool();
			}
		}
		player.storage.hujiaing = false;
		if (bool) {
			trigger.result = { bool: true, card: { name: "shan", isCard: true } };
			trigger.responded = true;
			trigger.animate = false;
			if (typeof event.current.ai.shown == "number" && event.current.ai.shown < 0.95) { 
				event.current.ai.shown +=0.3; 
				if(event.current.ai.shown> 0.95) event.current.ai.shown = 0.95;
			}
    		{{#a "responded" "insert" players="player|event.current"}}{{/a}}
			return;
		} else {
			{{#a "responded" "insert" players="player|event.current"}}{{/a}}
			event.current = event.current.next;
		}
	}
{{/content}}